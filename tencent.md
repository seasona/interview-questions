# 腾讯

## C++

### C++ 中智能指针和指针的区别是什么？
    
普通指针：存储地址的变量，可以直接修改内存，因为堆空间需要手动释放的原因，所以会出现内存泄漏、空悬指针的问题

智能指针：C++11引入的动态内存管理机制，通过C++的资源获取即初始化（Resource Acquisition Is Initialization）特性，智能指针离开作用域时释放该对象，并通过关联的删除器释放对象所占用的堆空间，比起普通指针可以解决一部分内存问题

### 指针和引用的区别

指针和引用主要有以下区别：

- 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。
- 引用初始化后不能被改变，指针可以改变所指的对象。
- 不存在指向空值的引用，但是存在指向空值的指针。

### 构造函数可以是虚函数吗？析构函数呢？

构造函数不行，从使用角度上来说，虚函数就是为了调用实际函数，而构造函数本身就是为了实例化实际对象，所以没有意义；从实现角度上来说，虚表指针是通过构造函数构建的，如果析构函数是虚函数就会产生矛盾
析构函数跟普通函数一样可以

### 简述 C++ 右值引用与转移语义

右值引用可用于修改右值，右值正常来说是无法被修改的，只能赋给const lvalue，而右值引用可以对右值进行修改

转移语义主要用于移动构造函数和移动赋值运算符，注意rule of five，一般用于有分配堆内存的对象，利用移动语义可以减少内存的重新拷贝，直接窃取右值对象中的内存数据。注意举例时，由于返回值优化(RVO)的存在，函数返回值的转移语义其实不起作用，但是例如STL中容器的各种操作是可以通过转移语义获得优化的，比如对象buffer本身内部有分配堆内存，复制是很耗时的，所以它内部有定义移动构造函数和移动复制函数

- https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners
- https://www.yuque.com/jiyanling/srtwox/khr8qy

### 简述 C++ 中智能指针的特点，简述 new 与 malloc 的区别

智能指针是通过指针占有并管理另一对象，并在离开作用域时释放该对象，通过关联的删除器释放对象并释放对象占有的内存

new其实是分为两步：分配内存+调用构造函数初始化，分配内存使用`operator new`，`operator new`内部使用`malloc`来分配内存，可以通过重载该操作符来定制化一些操作；分配内存后调用对象构造函数然后返回对象指针

malloc的话一般是使用系统调用，在linux下是一般是调用mmap系统调用来分配堆内存，可以通过flags参数来改变使用方式：一般进程内堆空间都是使用`MAP_PRIVATE`，如果使用`MAP_SHARED`就是开启了共享内存用于进程间通信，也可以将其映射到某一个文件用于进程间通信，一般是比read等系统调用更快，主要是减少了系统调用的开销

- https://www.cnblogs.com/huangfuyuan/p/9476951.html
- https://man7.org/linux/man-pages/man2/mmap.2.html
- https://www.cnblogs.com/slgkaifa/p/6887887.html

### C++ 11 有什么新特性? C++ 14? C++ 17? C++ 20?

- C++11
    - 引入了智能指针、auto自动推导、lambda表达式、右值引用
    - 引入了`<thread>`，`<atomic>`等标准库
- C++14
    - 主要是C++11引入的特性进行了扩展
- C++17
    - 引入的语言特性不是很多，主要有类模板实参推导等
    - 加入了`<string_view>`，`<filesystem>`等标准库
- C++20
    - 加入了很多语言特性：module、coroutine、concepts等
    - 加入了`<format>`等标准库

+ https://zh.cppreference.com/w/cpp/11
+ https://zh.cppreference.com/w/cpp/20

### STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？

vector类似数组，主要是一开始分配一块连续内存，内部是有三个迭代器指向起始、已存储位置、vector容器结尾位置。与数组不同的地方就是可以动态扩容，当已存储达到容器分配大小是，一般是重新开辟一块大小是原本倍数的连续内存，倍数由编译器决定，然后把旧空间的数据深拷贝到新内存空间，弃用原本的内存空间，所以是比较耗时的。常见的查询是O(1)，插入末尾算O(1)吧

list是双向链表吧，常数时间从容器任何位置插入和移除元素，一般是先find到位置然后再insert这样，O(n)

### C++中的四种cast

- const_cast: 加上或者删除const修饰
- dynamic_cast: 有检查的多态转换
- static_cast: 类似C中的强制类型转换，主要是多了一些检查
- reinterpret_cast：通过重新解释底层位模式在类型间转换，与static_cast的区别就是，对于int(2)转换到float(2)，因为两者的实际位存储不一样，所以static_cast是会将其内部的位进行修改的，而reinterpre_cast则不会编译成任何CPU指令，只是指示编译器将其看作新类型，所以int(2)还是以整型存储

### 深拷贝与浅拷贝区别是什么？

浅拷贝：比如类中存储一个指向已分配内存的指针，浅拷贝只会将该指针拷贝到新对象，两个对象共用的一个资源
深拷贝：深拷贝需要手动将分配一块新内存，将数据也拷贝过来，这种将对象所持有的其它资源一并拷贝的行为叫做深拷贝，必须显式地定义拷贝构造函数才能达到深拷贝的目的

### const、static 关键字有什么区别

const关键字本意是禁止修改变量的值，只是单纯的编译器进行标识，然后把变量放到只读段

static关键字起静态或线程存储期和内部连接的作用：

- 内部连接：主要是只是当前符号只能在当前翻译单元(translation unit)中使用
- 静态存储期：这类对象的存储在程序开始时分配，并在程序结束时解分配。这类对象只存在一个实例

### 只定义析构函数，会自动生成哪些构造函数？

三之法则：若某个类需要用户定义的析构函数、用户定义的复制构造函数或用户定义的复制赋值运算符，则它几乎肯定三者全部都需要

五之法则：因为用户定义析构函数、复制构造函数或复制赋值运算符的存在阻止移动构造函数和移动赋值运算符的隐式定义，所以任何想要移动语义的类必须声明全部五个特殊成员函数

### 简述 C++ 中内存对齐的使用场景

内存对齐可以加快内存读取速度，然而有的时候是不想要这个特性的，比如在嵌入式开发中内存字节分配都是固定的，另如TCP/IP协议栈中，数据包中的字节都是固定对应的，将内存中的数据包赋值给结构体时，此时就需要取消字节对齐，取消字节对齐一般是通过编译器支持的，比如GCC和Clang对应的就是 `__attribute__((packed))`

- https://www.yuque.com/jiyanling/srtwox/fqocdo

### 简述 C++ 从代码到可执行二进制文件的过程

预处理->编译->汇编->链接->二进制

预处理：1.宏替换，2.头文件包含
编译：转化为中间代码或者汇编语言，并进行一系列优化，`main.s`
汇编：这一步将生成ELF格式，将程序划分为若干段（数据段，代码段等），`main.o`
此时，已经生成elf中的section信息，也就是可以进行链接，但是执行所需的segment信息还没有生成

```c
There are 11 section headers, starting at offset 0x208:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       000000000000000d  0000000000000000  AX       0     0     1
  [ 2] .data             PROGBITS         0000000000000000  0000004d
       0000000000000000  0000000000000000  WA       0     0     1
  [ 3] .bss              NOBITS           0000000000000000  0000004d
       0000000000000000  0000000000000000  WA       0     0     1
  [ 4] .comment          PROGBITS         0000000000000000  0000004d
       000000000000002a  0000000000000001  MS       0     0     1
  [ 5] .note.GNU-stack   PROGBITS         0000000000000000  00000077
       0000000000000000  0000000000000000           0     0     1
  [ 6] .eh_frame         PROGBITS         0000000000000000  00000078
       0000000000000038  0000000000000000   A       0     0     8
  [ 7] .rela.eh_frame    RELA             0000000000000000  00000198
       0000000000000018  0000000000000018   I       8     6     8
  [ 8] .symtab           SYMTAB           0000000000000000  000000b0
       00000000000000d8  0000000000000018           9     8     8
  [ 9] .strtab           STRTAB           0000000000000000  00000188
       000000000000000e  0000000000000000           0     0     1
  [10] .shstrtab         STRTAB           0000000000000000  000001b0
       0000000000000054  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)
```

- bss段：通常是指用来存放程序中未初始化的全局变量的一块内存区域。
- data段：指用来存放程序中已初始化的全局变量的一块内存区域。
- rodata段：只读数据，const修饰的变量和字符串常量一般放在这里
- text段：指用来存放程序执行代码的一块内存区域。

链接：
- 静态链接：编译时进行链接
    - 空间和地址分配：扫描所有输入目标文件，获取各个段的长度、属性和位置，并且将所有符号定义都搜集起来放入全局符号表，将所有段合并
    - 符号解析和重定位：读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。因为需要将所有的过程文件都链接进最终文件，所以比较浪费空间，并且更新困难
- 动态链接：运行时进行链接

生成segment信息，程序可以执行


### 简述 STL 中的 map 的实现原理

map底层实现是红黑树，插入查询都是O(logn)，存储节点是std::pair，所以会出现first、second；unordered_map底层实现是哈希表

## 操作系统

### 中断

什么是中断？简单地说就是CPU在忙着作自己的事情，这时候硬件（比如说键盘按了一下）触发了一个电信号，这个信号通过中断线到达中断控制器i8259A，i8259A接受到这个信号后，向CPU发送INT信号申请CPU来执行刚才的硬件操作，并且将中断类型号也发给CPU，此时CPU保存当前正在做的事情（REST指令把程序计数器PC中的下一条待执行的指令的内存地址保存到栈）的情景现场，然后去处理这个申请，根据中断类型号找到它的中断向量（即中断程序在内存中的地址），然后去执行这段程序（这段程序已经写好，在内存中），执行完后再向i8259A发送一个INTA信号表示其已经处理完刚才的申请。此时CPU就可以继续做它刚才被打断做的事情了，将刚才保存的情景现场恢复出来，CPU继续执行接下来下面的程序

### 进程和线程之间有什么区别？

进程是资源分配的基本单位，线程是程序调度的基本单位。

Linux由于采用1对1的线程模型，所以进程和线程其实没有本质区别，都是运行的任务，进程fork()和线程pthread_create()，都是调用系统调用 clone，区别在于调用参数不同：线程会共享堆空间、文件描述符、信号等

- https://www.yuque.com/jiyanling/hgmlvr/gwwwqm

### 进程间有哪些通信方式？

- 管道：
- 信号：
- 消息队列：
- 共享内存：
- socket：
- 信号量：

+ https://www.yuque.com/jiyanling/zp90sn/riisyp#O9M1N

### 简述 socket 中 select 与 epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？

### Linux 进程调度中有哪些常见算法以及策略？

### 操作系统如何申请以及管理内存的？

- https://www.cnblogs.com/peterYong/p/6556619.html

### 简述 Linux 系统态与用户态，什么时候会进入系统态？

用户态：

系统态（内核态）：

系统调用或外部中断进入内核态

### 简述 LRU 算法及其实现方式

最近最少使用算法（LRU），当内存中没有可以用的页时会发生缺页中断，此时将最近最少使用的页的数据丢弃将新页置换进来。

可利用一个特殊的栈来保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。因此，栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页面号。

![](https://bkimg.cdn.bcebos.com/pic/f11f3a292df5e0fe494506fc526034a85fdf72ea?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U2MA==,g_7,xp_5,yp_5/format,f_auto)

### Linux系统下常用指令

cat top ps du grep chmod

### 线程间有哪些通信方式？

全局变量和锁机制，比如条件变量

### 线程切换上下文

1、切换页表全局目录
2、切换内核态堆栈
3、切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）
ip(instruction pointer)：指向当前执行指令的下一条指令
bp(base pointer): 用于存放执行中的函数对应的栈帧的栈底地址
sp(stack poinger): 用于存放执行中的函数对应的栈帧的栈顶地址
cr3:页目录基址寄存器，保存页目录表的物理地址
......
4、刷新TLB
5、系统调度器的代码执行

### 简述同步与异步的区别，阻塞与非阻塞的区别

### 简述操作系统中的缺页中断

在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。

- https://www.cnblogs.com/blythe/articles/7482031.html

### 简述操作系统中 malloc 的实现原理

+ https://www.yuque.com/jiyanling/srtwox/cu7u5t

### BIO、NIO 有什么区别？怎么判断写文件时Buffer已经写满？简述 Linux 的IO模型

- https://zhuanlan.zhihu.com/p/127170201

### 进程空间从高位到低位都有些什么？

<img src="https://www.programmersought.com/images/686/005227959398502bf6b4cc9280699cfe.png" style="zoom:50%" />

## 网络协议

### 简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？

- 三次握手：主要是防止两次握手情况下已失效的连接请求报文段又传送到服务器，两次握手下，如果一个已失效的连接请求报文段又传送到服务器，服务器会认为已建立连接并等待通信，会造成资源浪费，三次握手下，服务器会返回客户端确认段，因为是一个失效的请求，客户端会忽略，建立连接失败，就不会造成问题

【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

### HTTP 与 HTTPS 有哪些区别？

主要的差别在于TLS协议，TLS协议主要是使用了非对称加密算法，将内容加密，其中牵涉到了CA（Certificate Authority），网站会将公钥给CA，CA给证书

### 一次 HTTP 的请求过程中发生了什么？

1. 对www.baidu.com这个网址进行DNS域名解析，得到对应的IP地址
2. 根据这个IP，找到对应的服务器，发起TCP的三次握手
3. 建立TCP连接后发起HTTP请求
4. 服务器响应HTTP请求，浏览器得到html代码
5. 浏览器解析html代码，并请求html代码中的资源（如js、css图片等）（先得到html代码，才能去找这些资源）
6. 浏览器对页面进行渲染呈现给用户

### TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？

四层，传输层。TCP提供确认应答，超时重传，流量控制，拥塞控制、TCP差错控制，UDP不保证这些

### TCP 中的拥塞控制

拥塞控制是整个网络的控制：
接受窗口：接收方根据缓存空间许诺的窗口值，放在TCP首部
拥塞窗口：发送方根据当前网络的拥塞程度估计的窗口值，网络没阻塞就慢慢变大，阻塞了就变小，用到下面的拥塞控制算法
常见的拥塞控制算法：慢开始、拥塞避免、快重传、快恢复

### TCP 怎么保证可靠传输？

使用seq/ack机制，seq序号用于表示传输字节，比如当前包传输字节200，包大小100，下一次发包会是300，而ack确认号用于表示收到的数据序号，收到该大小100的包后，ack值会变为200+100，那么返回包时，发送方通过确认ack值就可以知道上个包发送成功，下一个包的序号就是从ack开始

重传机制，发送一个包后会启动一个计时器，如果在规定时间内没有收到包就会重传，TCP默认重传时间是200ms，会根据网络实时情况根据公式变化

### 从系统层面上，UDP如何保证尽量可靠？

一般是通过上层协议来确保可靠

### TCP 的 keepalive 了解吗？说一说它和 http 的 keepalive 的区别？

TCP的keepalive，是为了保持客户端和服务端的连接，为了鉴别连接中是没有数据发送还是连接中断，每隔一段时间会发送一个心跳包

HTTP的keepalive，就是在HTTP请求头中开启keepalive，这样就是长连接，不需要每次都建立TCP连接，可以连续的发送数据

### 简述 TCP 滑动窗口以及重传机制

滑动窗口主要是为了加快传输效率，原本一个请求发出去后要等待确认返回才能再发包，滑动窗口可以让发送方一次性发送多个包，只要双方确认好接收窗口与发送窗口，选择小的那个

重传机制：

- 第一种，如果未使用滑动窗口机制，发送的数据包没有收到确认应答包，那么数据都会被重发；如果使用了滑动窗口机制，即使确认应答包丢失，也不会导致数据包重发。
- 第二种，发送的数据包丢失，将导致数据包重发

### 简述 HTTP 1.0，1.1，2.0 的主要区别

- HTTP1.0：每次传输数据都需要重新建立一次TCP连接，短连接
- HTTP1.1：只需要建立一次TCP连接，之后可以连续发送数据，长连接，开启HTTP请求头中的keepalive
- HTTP2.0：在HTTP1.1的基础上，增加了多路复用，可以同时发送接收多个HTTP请求，类似于TCP的滑动窗口机制

- ▲ 7 简述 TCP 的 TIME_WAIT
- ▲ 5 HTTP 的方法有哪些？
- ▲ 4 简述 TCP 协议的延迟 ACK 和累计应答
- ▲ 1 简述 TCP 的报文头部结构
- ▲ 1 简述 TCP 半连接发生场景
- ▲ 1 什么是 SYN flood，如何防止这类攻击？

## 算法

- ▲ 29 10亿个数中如何高效地找到最大的一个数以及最大的第 K 个数
- ▲ 21 最大子序和 (Leetcode)
- ▲ 20 爬楼梯 (Leetcode)
- ▲ 18 用 Rand7() 实现 Rand10() (Leetcode)
- ▲ 15 AVL树和红黑树有什么区别？
- ▲ 15 给定一个包含 40亿 个无符号整数的大型文件，使用最多 1G 内存，对此文件进行排序
- ▲ 14 合并两个有序链表 (Leetcode)
- ▲ 14 路径总和 (Leetcode)
- ▲ 14 如果通过一个不均匀的硬币得到公平的结果？
- ▲ 13 实现快速排序
- ▲ 13 数组中的第 K 个最大元素 (Leetcode)
- ▲ 13 10亿条数据包括 id，上线时间，下线时间，请绘制每一秒在线人数的曲线图
- ▲ 13 删除排序链表中的重复元素 (Leetcode)
- ▲ 11 有序链表插入的时间复杂度是多少？
- ▲ 10 Hash 表常见操作的时间复杂度是多少？遇到 Hash 冲突是如何解决的？
- ▲ 9 环形链表 (Leetcode)
- ▲ 6 常用的限流算法有哪些？简述令牌桶算法原理
- ▲ 4 简述常见的负载均衡算法
- ▲ 1 反转链表 (Leetcode)
- ▲ 1 第一个只出现一次的字符 (Leetcode)

## 非技术

- ▲ 14 对加班有什么看法？
- ▲ 10 你的优势和劣势是什么？
- ▲ 7 与同事沟通的时候，如果遇到冲突了如何解决？
- ▲ 1 最近一年内遇到的最有挑战的事情是什么？

### 你平时都用RSS订阅什么？

reddit的programming和cpp节点，bartek的博客，DZone，lobsters，Youtube上的C++ Weekly
